---
layout: post
title: "Adding Two Unlimited Integers"
date: 2015-07-11
comments: true
categories: ["Algorithm"]
---

* Coding Interview Question 01<br>
Implement the following function in C/C++. Arguments X and Y are pointers to null-terminated strings containing non-negative base-10 whole numbers of unlimited size/length.  Allocate and return a string containing the base-10 representation of the sum of X and Y. (Leading zeros in the output are fine.) 

* function prototype: char *AddAsciiIntegers( const char *x, const char *y );

Analysis
--------
First how would you use this function? maybe like this:

```c
	const char x[] =   "2342342341119994567890234234234111999456789023423423411199945678902342342343";
    const char y[] = "890989092389238900890923898909238989092389890923898909238900089092389120311458";
    char * result = AddAsciiIntegers(x, y);

```

Someone will revert the string so it'll be more nature, but I won't.

Before coding I did a lot search on Google to find some codes about this, but nothing perfect found, so I decide to code it myself.

We'll use the algorithm we learned in grade school: add corresponding digits, plus a "carry" generated by previous overflows.

```c
char *
AddAsciiIntegers( const char *x, const char *y ) {
    int i = strlen(x);
    int j = strlen(y);
    size_t len = MAX(i, j) + 2;
    
    char * str_result = (char *)malloc(len);
    assert(str_result);

    int n = len - 1;
    int carry = 0;
    while (n--) {
        i--;
        j--;
        if (i >= 0 || j >= 0) {
            int sum = carry;
            if (i >= 0)
                sum += (x[i]-'0');
            if (j >= 0)
                sum += (y[j]-'0');
            
            str_result[n] = sum % 10 + '0';

            carry = sum / 10;
        }
        else {
            str_result[n] = carry + '0';
            break;
        }
    }

    str_result[len-1] = '\0';

    return str_result;
}
```

Optimize
--------
If X/Y is represented in int[], then we can add much more numbers at once.

Source Code:
--------
```c
/*
**  @file $RCSfile: q2.c,v $
**  big integer adding
**  @author $Author: Kevin $
**  @date $Date: 2015/07/01 08:02:41 $
**  @version $Revision: 0.01 $
**  @note Editor: Vim 6, Gcc 4.4.6, tab=4
**  @note Platform: CentOS release 6.3 (Final)
*/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h> 
#include <sys/time.h>
#include <string.h> 

/* copy from glibc */
#define MAX(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a > _b ? _a : _b; })

char *
AddAsciiIntegers( const char *x, const char *y ) {
    int i = strlen(x);
    int j = strlen(y);
    size_t len = MAX(i, j) + 2;
    
    char * str_result = (char *)malloc(len);
    assert(str_result);

    int n = len - 1;
    int carry = 0;
    while (n--) {
        i--;
        j--;
        if (i >= 0 || j >= 0) {
            int sum = carry;
            if (i >= 0)
                sum += (x[i]-'0');
            if (j >= 0)
                sum += (y[j]-'0');
            
            str_result[n] = sum % 10 + '0';

            carry = sum / 10;
        }
        else {
            str_result[n] = carry + '0';
            break;
        }
    }

    str_result[len-1] = '\0';

    return str_result;
}

int 
main(int argc, char ** argv) 
{
    #define TIME_ELAPSE(start, end) 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec - start.tv_usec
    const char x[] =   "2342342341119994567890234234234111999456789023423423411199945678902342342343";
    const char y[] = "890989092389238900890923898909238989092389890923898909238900089092389120311458";
    
    struct timeval start, end;
    
    gettimeofday( &start, NULL );
    char * result = AddAsciiIntegers(x, y);
    gettimeofday( &end, NULL);
    
    printf("result:%s\n", result);
    printf("\nlen: %lu, time cost: %ld us\n", strlen(result), TIME_ELAPSE(start, end));

    free(result);

    exit(EXIT_SUCCESS);
}


```

